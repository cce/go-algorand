// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"5+jR5MHo/f8LAAD//0GAPuoXywEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
