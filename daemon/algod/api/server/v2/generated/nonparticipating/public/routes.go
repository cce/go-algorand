// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
