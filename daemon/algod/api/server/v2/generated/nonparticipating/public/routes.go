// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
