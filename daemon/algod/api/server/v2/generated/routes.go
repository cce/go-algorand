// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
